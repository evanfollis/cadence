[
  {
    "id": "blueprint-2-rollback-shellrunner",
    "title": "Add rollback() + dirty_repo flag to ShellRunner",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Enhance src/cadence/dev/shell.py: 1. Internal helper _git_apply_reverse(patch) (mirror of git_apply with -R). 2. Public def rollback(self, patch:str | None) -> bool which: \u2022 Returns True if reverse-apply succeeds. \u2022 On failure sets self.dirty_repo = True, records failed_rollback in TaskRecord, and returns False. 3. self.dirty_repo defaults to False on instantiation and after every successful git_commit. 4. Mark phase \u2018rollback_done\u2019 when rollback succeeds (optional)."
  },
  {
    "id": "blueprint-2-dirty-guard-orchestrator",
    "title": "Integrate dirty-repo guard in DevOrchestrator",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Edit src/cadence/dev/orchestrator.py: \u2022 At the very beginning of run_task_cycle, if self.shell.dirty_repo is True, log state blocked_dirty_repo and raise RuntimeError(\"Repository dirty after failed rollback\"). \u2022 Replace existing _attempt_rollback() logic with call to self.shell.rollback(rollback_patch). If it returns False, abort cycle early with success=False payload containing \"dirty_repo\": True."
  },
  {
    "id": "blueprint-2-docs-rollback",
    "title": "Document rollback & dirty-repo in DEV_PROCESS.md",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Add small ASCII flow diagram under Failure Handling in docs/DEV_PROCESS.md: `patch_apply \u2192 test_fail \u2192 rollback \u2192 [ok] | [rollback_fail \u2192 dirty_repo flag \u2192 block next loop]` Describe manual/unblock options for developers (e.g. git reset --hard then self.shell.dirty_repo=False). Ensure linter passes."
  },
  {
    "id": "blueprint-2-test-rollback",
    "title": "Strengthen test_failed_rollback.py",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Update or create tests/test_failed_rollback.py: 1. Create tmp repo with two commits. 2. Forge a ChangeSet that intentionally fails tests (e.g. syntax error). 3. Run orchestrator cycle; assert: result['success'] is False, result['stage'] == 'test', shell.dirty_repo is False. 4. Simulate rollback failure (e.g. corrupt patch) and assert dirty_repo is True and subsequent run_task_cycle immediately aborts with blocked_dirty_repo. Use pytest.raises."
  },
  {
    "id": "c9649ee3-8306-4aaf-aa52-1036be5d830a",
    "title": "Add rollback() + dirty_repo flag to ShellRunner",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:21:01.031833+00:00",
    "change_set": {
      "edits": [
        {
          "path": "src/cadence/dev/shell.py",
          "after": null,
          "before_sha": null,
          "mode": "modify"
        }
      ],
      "message": "Enhance ShellRunner in src/cadence/dev/shell.py: 1) Add _git_apply_reverse(patch) as internal helper (mirror of git_apply but uses -R); 2) Add public rollback(self, patch: str | None) -> bool: runs _git_apply_reverse, returns True if success, else sets self.dirty_repo = True, records failed_rollback in TaskRecord, returns False; 3) self.dirty_repo defaults to False at instantiation and after successful git_commit; 4) Optionally, mark phase 'rollback_done' if rollback succeeds.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-2-rollback-shellrunner"
  },
  {
    "id": "7b991de0-0e45-4f1e-94fc-fb32955b730b",
    "title": "Integrate dirty-repo guard in DevOrchestrator",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:21:04.915960+00:00",
    "change_set": {
      "edits": [
        {
          "path": "src/cadence/dev/orchestrator.py",
          "after": "# ...\n# At the beginning of run_task_cycle, add dirty repo guard:\ndef run_task_cycle(self, *args, **kwargs):\n    # Dirty repo guard\n    if self.shell.dirty_repo:\n        self.log_state('blocked_dirty_repo')\n        raise RuntimeError(\"Repository dirty after failed rollback\")\n    # ... rest of run_task_cycle code ...\n    # Replace _attempt_rollback logic with shell.rollback(rollback_patch):\n    # Old code:\n    # success = self._attempt_rollback()\n    # if not success:\n    #     ... (handle failure)\n    # New code:\n    success = self.shell.rollback(rollback_patch)\n    if not success:\n        payload = {\"dirty_repo\": True}\n        # Other logic to abort early with success=False and payload\n        return {\"success\": False, **payload}\n    # ... rest of cycle\n",
          "before_sha": null,
          "mode": "modify"
        }
      ],
      "message": "Integrate dirty-repo guard in DevOrchestrator:\n- In src/cadence/dev/orchestrator.py, at the start of run_task_cycle, if self.shell.dirty_repo is True, log state 'blocked_dirty_repo' and raise a RuntimeError.\n- Replace _attempt_rollback() logic with self.shell.rollback(rollback_patch), and if it returns False, abort cycle early with success=False and dirty_repo=True.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-2-dirty-guard-orchestrator"
  },
  {
    "id": "3223c9b7-7482-4dbb-a785-2a1496317631",
    "title": "Document rollback & dirty-repo in DEV_PROCESS.md",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:21:11.778967+00:00",
    "change_set": {
      "edits": [
        {
          "path": "docs/DEV_PROCESS.md",
          "after": "## Failure Handling\n\nWhen patches fail to apply cleanly or tests fail, the following process occurs:\n\n```\npatch_apply \u2192 test_fail \u2192 rollback \u2192 [ok]\n                          \u2502\n                          \u2514\u2500\u2500 [rollback_fail \u2192 dirty_repo flag \u2192 block next loop]\n```\n\n- If rollback succeeds ([ok]), the process may continue.\n- If rollback fails, a `dirty_repo` flag is set, preventing further automated actions until resolved.\n\n### Unblocking a Dirty Repository\nTo unblock development after a dirty repo:\n\n1. Manually reset the repository:\n   ```\n   git reset --hard\n   ```\n2. In Python, clear the dirty repo flag:\n   ```python\n   self.shell.dirty_repo = False\n   ```\n\nYou can now proceed with new patches or test cycles.\n",
          "before_sha": null,
          "mode": "modify"
        }
      ],
      "message": "Document process for rollback and dirty-repo handling after patch application failure.\n\n- Add an ASCII flow diagram under Failure Handling in docs/DEV_PROCESS.md outlining rollback and dirty_repo logic.\n- Explain manual/unblock steps for developers (e.g. git reset --hard, updating self.shell.dirty_repo=False).\n- Ensure style aligns with linter requirements.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-2-docs-rollback"
  },
  {
    "id": "a1598bf0-e0a6-41de-b744-0d58112b8181",
    "title": "Strengthen test_failed_rollback.py",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:21:21.305198+00:00",
    "change_set": {
      "edits": [
        {
          "path": "tests/test_failed_rollback.py",
          "after": "import os\nimport pytest\nfrom orchestrator import run_task_cycle, Orchestrator, Shell\nfrom changeset import ChangeSet\n# Add any additional imports needed\n\n@pytest.fixture\ndef tmp_git_repo(tmp_path):\n    from git import Repo\n    repo_dir = tmp_path / \"repo\"\n    repo_dir.mkdir()\n    repo = Repo.init(str(repo_dir))\n    test_file = repo_dir / \"test.txt\"\n    test_file.write_text(\"initial content\\n\")\n    repo.index.add([str(test_file)])\n    repo.index.commit(\"initial commit\")\n    test_file.write_text(\"second content\\n\")\n    repo.index.add([str(test_file)])\n    repo.index.commit(\"second commit\")\n    return repo, repo_dir\n\ndef test_failed_rollback_logic(tmp_git_repo):\n    repo, repo_dir = tmp_git_repo\n    shell = Shell(cwd=str(repo_dir))\n    orchestrator = Orchestrator(shell=shell)\n    # Forge a ChangeSet that will fail tests (e.g., introduce syntax error)\n    changeset = ChangeSet(\n        message=\"break test\",\n        edits=[{\n            \"path\": \"broken.py\",\n            \"mode\": \"add\",\n            \"after\": \"def broken(:\\n    pass\\n\"\n        }]\n    )\n    # Apply ChangeSet, which should introduce an error\n    result = orchestrator.run_cycle([changeset])\n    assert result['success'] is False\n    assert result['stage'] == 'test'\n    assert shell.dirty_repo is False\n    # Corrupt the patch or make rollback fail on purpose\n    # For example, delete .git directory to simulate unrecoverable rollback\n    import shutil\n    shutil.rmtree(os.path.join(str(repo_dir), '.git'))\n    # Re-apply the changeset, should fail rollback and mark repo as dirty\n    with pytest.raises(Exception) as excinfo:\n        orchestrator.run_task_cycle([changeset])\n    assert getattr(shell, 'dirty_repo', False) is True\n    assert 'blocked_dirty_repo' in str(excinfo.value)\n",
          "before_sha": null,
          "mode": "modify"
        }
      ],
      "message": "Strengthen tests/test_failed_rollback.py with a test that: (1) creates a tmp repo and two commits, (2) forges a ChangeSet with a test-breaking error, (3) runs an orchestrator cycle and asserts test failure, dirty_repo handling, and (4) simulates a corrupt rollback and checks appropriate abort and exception with pytest.raises.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-2-test-rollback"
  }
]