[
  {
    "id": "task-round2-001",
    "title": "TASK-1 Auto-replenish backlog when empty",
    "type": "story",
    "status": "open",
    "created_at": "2025-06-22T00:00:00Z",
    "description": "Goal: Keep the pipeline perpetually flowing without human babysitting.\n\nImplementation steps:\n1. Add DevOrchestrator._ensure_backlog(). If self.backlog.list_items(\"open\") is empty, call TaskGenerator.generate_tasks(mode=\"micro\", count=<N>). N default = 3; expose CLI flag. Persist the newly generated tasks with BacklogManager.add_item(). Record snapshot: state=\"backlog_replenished\", extra={\"count\": N}.\n2. Call _ensure_backlog() at the very top of run_task_cycle().\n3. Unit test: run an orchestrator in a temp repo with an empty backlog, assert it auto-populates.\n\nAcceptance: run_task_cycle(interactive=False) no longer raises RuntimeError when no tasks exist."
  },
  {
    "id": "task-round2-002",
    "title": "TASK-2 Wire EfficiencyAgent as mandatory second review",
    "type": "story",
    "status": "open",
    "created_at": "2025-06-22T00:00:00Z",
    "description": "Goal: Conform to DEV_PROCESS phase table (Review → Reasoning and Efficiency).\n\nImplementation steps:\n1. In DevOrchestrator.__init__ create self.efficiency = get_agent(\"efficiency\").\n2. After first review passes, call eff_review = self.efficiency.run_interaction(<prompt_with_patch>) or reuse TaskReviewer; tag state \"efficiency_reviewed\".\n3. Fail the task cycle unless both reviews pass.\n4. Record both review results with distinct states: \"patch_reviewed_reasoning\" / \"patch_reviewed_efficiency\".\n5. Extend phase flags so ShellRunner.git_commit requires \"efficiency_passed\" as well.\n\nAcceptance: a commit cannot occur unless both reviews have succeeded; tests updated accordingly."
  },
  {
    "id": "task-round2-003",
    "title": "TASK-3 First-class MetaAgent hook",
    "type": "story",
    "status": "open",
    "created_at": "2025-06-22T00:00:00Z",
    "description": "Goal: Provide real-time governance / drift detection per DEV_PROCESS.\n\nImplementation steps:\n1. Add simple MetaAgent.analyse(run_summary: dict) stub that just logs or appends to TaskRecord.\n2. Call it at the end of every run_task_cycle() (success or failure) with the full result dict.\n3. Record state \"meta_analysis\" plus whatever telemetry the MetaAgent returns.\n4. Keep invocation behind config[\"enable_meta\"] flag (default True).\n\nAcceptance: TaskRecord shows a meta_analysis snapshot for every cycle; meta failures do not crash the run."
  },
  {
    "id": "task-round2-004",
    "title": "TASK-4 Harden TaskReviewer rule parsing",
    "type": "story",
    "status": "open",
    "created_at": "2025-06-22T00:00:00Z",
    "description": "Goal: Unknown rule types must never be ignored silently.\n\nImplementation steps:\n1. In TaskReviewer._load_ruleset raise PatchReviewError or emit logger.warning when type is unrecognised.\n2. Provide strict constructor flag (default True).\n3. Add regression test loading a ruleset with an invalid type → expect exception or warning.\n\nAcceptance: CI fails (or logs) on an unrecognised rule type; no silent pass."
  },
  {
    "id": "task-round2-005",
    "title": "TASK-5 Expand enforce_phase → include review guards",
    "type": "story",
    "status": "open",
    "created_at": "2025-06-22T00:00:00Z",
    "description": "Goal: Prevent any commit unless \"review_passed\" and \"efficiency_passed\" flags exist.\n\nImplementation steps:\n1. Add new decorator usage or explicit check in ShellRunner.git_commit: required = [\"patch_applied\", \"tests_passed\", \"review_passed\", \"efficiency_passed\"].\n2. Set those flags inside DevOrchestrator right after each successful review.\n3. Update tests in test_phase_ordering_and_precheck.py to assert commit fails without both review flags.\n\nAcceptance: New tests pass; commit cannot bypass approval lattice."
  },
  {
    "id": "task-round2-006",
    "title": "TASK-6 Cross-process file-locking for backlog & record",
    "type": "story",
    "status": "open",
    "created_at": "2025-06-22T00:00:00Z",
    "description": "Goal: Prevent two orchestrators on the same repo from racing.\n\nImplementation steps:\n1. Add lightweight cross-process lock via filelock (pip-light) or portalocker.\n2. Acquire the lock in .save() and .load() of BacklogManager & TaskRecord in addition to the existing RLock. Lock file path = <jsonfile>.lock.\n3. Time-out (e.g., 10 s) then raise custom FileLockTimeoutError; caller should retry or alert.\n4. Add smoke test: spawn two multiprocessing.Process objects that hammer .add_item; assert no JSON corruption.\n\nAcceptance: Concurrency test passes; manual ctrl-C leaves .lock cleaned up."
  },
  {
    "id": "task-round2-007",
    "title": "TASK-7 Graceful LLMClient fallback when env is missing",
    "type": "story",
    "status": "open",
    "created_at": "2025-06-22T00:00:00Z",
    "description": "Goal: Allow offline/CI runs without exporting OPENAI_API_KEY.\n\nImplementation steps:\n1. In LLMClient.__init__, if api_key is missing: log a warning; enter stub-mode: .call() and .acall() return a canned message (e.g., \"LLM unavailable\").\n2. Add self.stub = True flag; tests can assert behaviour.\n3. Update existing CI tests to expect stub-mode (they already monkey-patch OpenAI).\n\nAcceptance: Running orchestrator without the env var no longer crashes; warning is emitted exactly once per process."
  }
]