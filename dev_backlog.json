[
  {
    "id": "blueprint-1-filemutex",
    "title": "Create cross-process FileMutex helper",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Implement src/cadence/dev/locking.py defining: class FileMutex: \u2022 Context-manager acquires exclusive lock on <target_path>.lock. \u2022 POSIX: fcntl.flock, Windows: msvcrt.locking, otherwise no-op stub with warning. \u2022 Exposes .path (lockfile) and .acquired boolean. Add docstring with platform notes and example usage."
  },
  {
    "id": "blueprint-2-integrate-mutex",
    "title": "Guard backlog & record JSON writes with FileMutex",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Edit backlog.py and record.py: \u2022 Wrap all disk I/O (save, load, _persist) in `with FileMutex(self.path): \u2026` in addition to existing RLock. \u2022 Remove any redundant tmp-file rename race comments. Preserve existing atomic-swap semantics."
  },
  {
    "id": "blueprint-3-audit-lock",
    "title": "Unify audit log locking via FileMutex",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "In src/cadence/audit/agent_event_log.py and audit/llm_call_log.py: \u2022 Delete the conditional `from filelock import FileLock` import. \u2022 Import FileMutex and use it in place of FileLock (same semantics: `with FileMutex(jsonl_path):`). \u2022 If FileMutex is stub (no lock), behaviour matches old optional dependency path."
  },
  {
    "id": "blueprint-4-docs-update",
    "title": "Document mutex in DEV_PROCESS.md",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Add bullet under **Persistence** subsection in docs/DEV_PROCESS.md: \u201cBacklog and TaskRecord writes are protected by FileMutex (fcntl/msvcrt) to prevent multi-process clobber.\u201d Ensure phase-table linter still passes."
  },
  {
    "id": "blueprint-5-mutex-test",
    "title": "Add test_file_mutex.py",
    "type": "blueprint",
    "status": "archived",
    "created_at": "2025-06-24T00:00:00Z",
    "description": "Create new test that: 1. Uses tempfile.TemporaryDirectory() as isolated repo. 2. Spawns two `python -c` subprocesses that each instantiate BacklogManager on the same JSON file and append a unique task (sleep 0.1 between writes). 3. Wait for both to finish; load JSON; assert len(list_items)==2 and file is valid. Skip on Windows if multiprocessing spawn causes flake (mark xfail)."
  },
  {
    "id": "82052b8a-90cb-46de-8bfc-afda611bfa81",
    "title": "Create cross-process FileMutex helper",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:18:27.751252+00:00",
    "change_set": {
      "edits": [
        {
          "path": "src/cadence/dev/locking.py",
          "after": "import os\nimport sys\nimport warnings\n\nclass FileMutex:\n    \"\"\"\n    Context manager for cross-process file-based mutex locking.\n\n    On POSIX, uses fcntl.flock for advisory locking.\n    On Windows, uses msvcrt.locking for exclusive file locks.\n    On unsupported platforms, acts as a stub and issues a warning.\n\n    Attributes:\n        path (str): Path to the lock file (<target_path>.lock)\n        acquired (bool): True if the lock is held by this context, else False.\n\n    Example:\n        >>> with FileMutex('/tmp/myresource') as mtx:\n        ...     if mtx.acquired:\n        ...         # critical section\n        ...         pass\n\n    Notes:\n        - Lock files are named <target_path>.lock\n        - Lock is released on exit from context\n        - Advisory: all cooperating processes must use this mechanism\n    \"\"\"\n    def __init__(self, target_path):\n        self._file = None\n        self.acquired = False\n        self.path = f\"{target_path}.lock\"\n\n    def __enter__(self):\n        if sys.platform.startswith('linux') or sys.platform.startswith('darwin') or 'bsd' in sys.platform:\n            try:\n                import fcntl\n                self._file = open(self.path, 'w')\n                fcntl.flock(self._file, fcntl.LOCK_EX)\n                self.acquired = True\n            except Exception as e:\n                warnings.warn(f\"FileMutex failed to acquire POSIX lock: {e}\")\n                self.acquired = False\n        elif sys.platform.startswith('win'):\n            try:\n                import msvcrt\n                self._file = open(self.path, 'a+')\n                self._file.seek(0)\n                msvcrt.locking(self._file.fileno(), msvcrt.LK_NBLCK, 1)\n                self.acquired = True\n            except Exception as e:\n                warnings.warn(f\"FileMutex failed to acquire Windows lock: {e}\")\n                self.acquired = False\n        else:\n            warnings.warn(f\"FileMutex: Platform {sys.platform} not supported; lock is a no-op.\")\n            self.acquired = True\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if sys.platform.startswith('linux') or sys.platform.startswith('darwin') or 'bsd' in sys.platform:\n            try:\n                if self._file:\n                    import fcntl\n                    fcntl.flock(self._file, fcntl.LOCK_UN)\n                    self._file.close()\n            except Exception:\n                pass\n        elif sys.platform.startswith('win'):\n            try:\n                if self._file:\n                    import msvcrt\n                    self._file.seek(0)\n                    msvcrt.locking(self._file.fileno(), msvcrt.LK_UNLCK, 1)\n                    self._file.close()\n            except Exception:\n                pass\n        self.acquired = False\n        self._file = None\n",
          "before_sha": null,
          "mode": "add"
        }
      ],
      "message": "Implement FileMutex class in src/cadence/dev/locking.py for cross-process locking using platform-appropriate mechanisms. Adds context manager, .acquired, .path, and a comprehensive docstring with example and notes.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-1-filemutex"
  },
  {
    "id": "2fe82233-5de9-45a4-9ff1-cec62d1a7c2b",
    "title": "Guard backlog & record JSON writes with FileMutex",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:18:29.575469+00:00",
    "change_set": {
      "edits": [
        {
          "path": "backlog.py",
          "after": null,
          "before_sha": null,
          "mode": "modify"
        },
        {
          "path": "record.py",
          "after": null,
          "before_sha": null,
          "mode": "modify"
        }
      ],
      "message": "Wrap all JSON disk I/O in backlog.py and record.py with FileMutex(self.path), in addition to RLock. Remove outdated tmp/rename race comments but preserve atomic file swap semantics.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-2-integrate-mutex"
  },
  {
    "id": "108e52ea-3404-459f-994c-27d875b6bee8",
    "title": "Unify audit log locking via FileMutex",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:18:31.315827+00:00",
    "change_set": {
      "edits": [
        {
          "path": "src/cadence/audit/agent_event_log.py",
          "after": null,
          "before_sha": null,
          "mode": "modify"
        },
        {
          "path": "src/cadence/audit/llm_call_log.py",
          "after": null,
          "before_sha": null,
          "mode": "modify"
        }
      ],
      "message": "Unify audit log locking by replacing FileLock with FileMutex in audit_event_log.py and llm_call_log.py. Remove conditional import for FileLock, import FileMutex, and use it in its place. Ensure FileMutex is used with same usage pattern as FileLock, and that stub fallback behavior is preserved.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-3-audit-lock"
  },
  {
    "id": "365f39d0-e7b7-464b-83c8-90797f5fcddd",
    "title": "Document mutex in DEV_PROCESS.md",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:18:32.745906+00:00",
    "change_set": {
      "edits": [
        {
          "path": "docs/DEV_PROCESS.md",
          "after": "- Backlog and TaskRecord writes are protected by FileMutex (fcntl/msvcrt) to prevent multi-process clobber.",
          "before_sha": null,
          "mode": "modify"
        }
      ],
      "message": "Document FileMutex protection of Backlog and TaskRecord writes in DEV_PROCESS.md under Persistence section.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-4-docs-update"
  },
  {
    "id": "f80737ea-9f47-44cb-946f-426e9aeefdc0",
    "title": "Add test_file_mutex.py",
    "type": "micro",
    "status": "open",
    "created_at": "2025-06-25T03:18:39.611505+00:00",
    "change_set": {
      "edits": [
        {
          "path": "tests/test_file_mutex.py",
          "after": "import os\nimport sys\nimport json\nimport time\nimport tempfile\nimport subprocess\nimport platform\nimport pytest\n\n# Skip/xfail for Windows multiprocessing flakiness\ndef should_xfail():\n    return sys.platform.startswith(\"win\")\n\ndef test_file_mutex():\n    if should_xfail():\n        pytest.xfail(\"Likely flaky on Windows multiprocessing spawn\")\n    with tempfile.TemporaryDirectory() as d:\n        backlog_file = os.path.join(d, \"backlog.json\")\n        code = (\n            \"from your_module import BacklogManager; \"\n            \"import sys; bm=BacklogManager(sys.argv[1]); bm.add({'task': sys.argv[2]}); import time; time.sleep(0.1)\"\n        )\n        # Use unique task names\n        cmd1 = [sys.executable, \"-c\", code, backlog_file, \"task1\"]\n        cmd2 = [sys.executable, \"-c\", code, backlog_file, \"task2\"]\n        p1 = subprocess.Popen(cmd1)\n        p2 = subprocess.Popen(cmd2)\n        p1.wait()\n        p2.wait()\n        # Validate file exists and both tasks are present\n        with open(backlog_file, 'r') as f:\n            items = json.load(f)\n            assert isinstance(items, list)\n            assert len(items) == 2\n        # Optional structure/content check: each task present?\n        task_names = {item['task'] for item in items}\n        assert task_names == {\"task1\", \"task2\"}\n",
          "before_sha": null,
          "mode": "add"
        }
      ],
      "message": "Add test_file_mutex.py to test concurrent BacklogManager access to a JSON file. The test uses tempfile.TemporaryDirectory() as an isolated repo. It spawns two python subprocesses, each instantiating BacklogManager (on the same file) and appending a unique task, sleeping 0.1s between writes. The test waits for both processes to finish, verifies the JSON contains both tasks (len==2), and asserts file validity. Skips or marks xfail on Windows if spawn issues cause flakiness.",
      "author": "",
      "meta": {}
    },
    "parent_id": "blueprint-5-mutex-test"
  }
]