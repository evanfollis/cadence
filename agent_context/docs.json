{
  "docs/granular_workflow.txt": "Below is an ultra-granular, source-driven trace of what actually happens to a single task, beginning with the raw backlog JSON file on disk and ending (when everything goes well) with an archived, completed task.  Every statement that is executed in the happy-path is accounted for.  Whenever the static code reveals an ambiguity, contradiction, or outright hole, it is called out in “GAP ⟶ …” blocks.\n\nLines are referenced with the exact file / function / line-number (≈) from the current repository you provided (src/…).  Indentation shows call-stack depth.\n\n────────────────────────────────────────────────────────────────────────────\n0.  THE BACKLOG FILE ON DISK\n────────────────────────────────────────────────────────────────────────────\n• Path expected by DevOrchestrator CONFIG = \"dev_backlog.json\"\n(src/cadence/dev/orchestrator.py ≈L34; command-center uses same default)\n\nGAP ⟶ Docs & user prompt mention “./backlog/backlog.json”.\nCode never looks at that path.  Unless the caller’s CONFIG overrides\nbacklog_path, the file must be exactly dev_backlog.json.\n\nAssume therefore dev_backlog.json exists and contains valid UTF-8 JSON.\n\n────────────────────────────────────────────────────────────────────────────\n\n1.  DevOrchestrator object is created ──────────────────────────────────────────────────────────────────────────── \ncall DevOrchestrator.init(config) (orchestrator.py ≈L20)\n1.1  BacklogManager instantiation\n• BacklogManager.init(backlog_path)  (backlog.py ≈L31)\n\n 1.1.1 BacklogManager.load()             (backlog.py ≈L58)\n        ├─ opens file `dev_backlog.json`\n        ├─ json.load → Python list[dict]  (ValueError if not list)\n        ├─ for each task → _normalize_task(task)  (≈L73)\n            • fills defaults, generates UUID if missing\n            • DOES NOT deduplicate IDs at load time\n        └─ self._items now holds in-memory backlog\n\n 1.1.2 returns control to DevOrchestrator.__init__\n\n1.2  TaskGenerator / TaskExecutor / TaskReviewer / ShellRunner / TaskRecord\nare all constructed but do nothing IO-wise yet\n(orchestrator.py ≈L23–28).\n– TaskGenerator loads template only if template_file supplied.\n– TaskRecord loads or creates dev_record.json (record.py ≈L26).\n\n────────────────────────────────────────────────────────────────────────────\n2.  One run of run_task_cycle()  (orchestrator.py ≈L47)\n────────────────────────────────────────────────────────────────────────────\nAssume caller invokes\norch.run_task_cycle(select_id=None, interactive=False)\nto let the orchestrator pick the first open task automatically.\n\n2.1  SELECT TASK                                         (≈L65-84)\n• open_tasks = BacklogManager.list_items(\"open\")    (backlog.py ≈L38)\n• Task chosen = open_tasks[0]\n• Prints shortlist (for CLI only)\n• No state change yet\n\n GAP ⟶ No lock around backlog; concurrent writers could reorder tasks.\n2.2  RECORD: “build_patch”                               (record.py ≈L19)\nTaskRecord.save(task, state=\"build_patch\")\n• _find_or_create_record creates new entry keyed by task[\"id\"]\n• Snapshots the current task dict\n\n2.3  BUILD PATCH                                         (executor.py ≈L19-56)\npatch = TaskExecutor.build_patch(task)\n\n Detailed internal sequence:\n    a) diff_info = task.get(\"diff\")          ↘ if None → PatchBuildError\n    b) Extract 'file', 'before', 'after'\n    c) Ensure newline at EOF for valid diff\n    d) difflib.unified_diff → List[str]\n    e) join → `patch`\n    f) if `not patch.strip()` → PatchBuildError\n Returns patch str (unapplied)\n\n GAP ⟶ If the task came from backlog with no \"diff\" key, the call throws\n        and the entire cycle aborts; there is no earlier validation.\n2.4  RECORD: “patch_built”                               (record.py again)\nextra={\"patch\": patch}\n\n2.5  REVIEW PATCH                                        (reviewer.py ≈L15-66)\nreview = TaskReviewer.review_patch(patch, context=task)\n\n Rule pipeline (default):\n    • not_empty_rule\n    • startswith_rule\n    • contains_todo_rule\n    • size_limit_rule\n Returns dict {\"pass\": bool, \"comments\": str}\n\n If review[\"pass\"] is False:\n    – RECORD already done\n    – run_task_cycle returns {\"success\": False, \"stage\": \"patch_review\"}\n\n GAP ⟶ No facility to auto-refine or request changes; cycle just ends.\n2.6  APPLY PATCH (only if review pass)                   (shell.py ≈L17-41)\nShellRunner.git_apply(patch)\na) writes patch to tmpfile\nb) subprocess.run([\"git\", \"apply\", tmpfile])\nc) if returncode != 0 → ShellCommandError\n\n RECORD: “patch_applied” (no extra payload)\n\n GAP ⟶ If git apply fails *after* review pass there is no catch block;\n        exception escapes → run_task_cycle except → prints “[X] Cycle failed”\n        but state “patch_apply_failed” is never saved.\n2.7  RUN PYTEST                                          (shell.py ≈L43-75)\ntest_result = run_pytest()\na) default path = \"./tests\" (or repo root param)\nb) subprocess.run([\"pytest\", \"-q\", path])\nc) returns {\"success\": bool, \"output\": str}\n\n RECORD: “pytest_run”, extra={\"pytest\": test_result}\n\n If tests fail:\n    – run_task_cycle returns {\"success\": False, \"stage\": \"test\"}\n\n GAP ⟶ No automatic reversion of applied patch on failure.  \n        Working tree is now dirty.\n2.8  COMMIT                                              (shell.py ≈L77-115)\nsha = git_commit(commit_msg)\na) git add -A\nb) git commit -m msg\nc) git rev-parse HEAD → SHA str\n\n RECORD: “committed”, extra={\"commit_sha\": sha}\n\n GAP ⟶ If git commit finds “nothing to commit”, ShellCommandError is raised\n        and run_task_cycle aborts.  The patch was applied & tests passed\n        but the record never stores that failure reason.\n2.9  BACKLOG STATUS UPDATE                               (backlog.py ≈L100)\nBacklogManager.update_item(task_id, {\"status\": \"done\"})\nBacklogManager.archive_completed()                  (≈L46-56)\n\n • archive_completed loops over in-memory items,\n   mutating those with status \"done\" → \"archived\", then save()\n\n SAVE writes full backlog JSON via tmp-swap\n\n GAP ⟶ The `task` variable captured earlier is **not** mutated with the\n        new status values; yet it is used again in the final record step.\n        Therefore TaskRecord.history shows stale `\"status\": \"open\"`.\n2.10 RECORD: “archived”  (record.py save again)\nextra={} – but task snapshot is stale (see previous GAP)\n\n  Cycle returns {\"success\": True, \"commit\": sha, \"task_id\": …}\n────────────────────────────────────────────────────────────────────────────\n3.  OFF-HAPPY-PATH & MISSING PIECES\n────────────────────────────────────────────────────────────────────────────\nBelow are all discoverable holes, each traceable to concrete lines.\n\n1. Backlog path mismatch (docs vs code) (see §0)\n2. No generator→backlog link: TaskGenerator never invoked to repopulate an empty backlog. run_task_cycle just throws. (orchestrator.py ≈L59)\n3. No concurrency protection on BacklogManager; race conditions possible in multi-thread / multi-process orchestration. (backlog.py)\n4. Record states are partially silent on failure branches: • git_apply failure • git_commit “nothing to commit” • Unexpected exceptions in shell or executor\n5. Patch rollback logic absent; failed tests leave working tree modified and inconsistent with commit history.\n6. Task snapshot drift: final “archived” history entry does not reflect ‘status’: 'archived'. (orchestrator.py ≈L114)\n7. Meta-agent, EfficiencyAgent second review, and strict phase table (docs/DEV_PROCESS.md) are declared but never invoked.\n8. No top-level guard that prevents skipping phases; a caller could call ShellRunner.git_commit directly and bypass review.\n9. TaskReviewer ruleset loading silently ignores unknown rule types instead of alerting; potential policy slip. (reviewer.py ≈L70-91)\n10. TaskExecutor does not verify that diff ‘before’ truly matches file on disk; stale diff can apply hunks out-of-context.\n────────────────────────────────────────────────────────────────────────────\n4.  RECOMMENDED NEXT BRIDGES (minimal code touches)\n────────────────────────────────────────────────────────────────────────────\n• Add BacklogManager.lock (threading.RLock) around all mutators.\n• On every failure branch in run_task_cycle, call\nrecord.save(task, state=\"failed_<stage>\", extra={...}).\n• After git_apply but before tests, compute and save a reverse diff\nso orchestrator can automatically rollback on failure.\n• Mutate local task variable after backlog.update_item so archive\nsnapshot is truthful.\n• Provide DevOrchestrator.ensure_backlog() that calls\nTaskGenerator.generate_tasks when backlog empty.\n• Wire second review phase (EfficiencyAgent) to honour docs/DEV_PROCESS.md.\n• Expose a decorator or context manager to enforce phase sequencing\nand prevent direct access to ShellRunner in user code.\n\nThat is the complete, code-verifiable journey from JSON backlog entry to archived task, with every identifiable gap surfaced.",
  "docs/NORTH_STAR.md": "\n# CADENCE PLATFORM — NORTH STAR BLUEPRINT\n\n*Last‑updated: 2025‑06‑20 (UTC‑05:00)*\n\n## 1 · Mission\n\n> **Industrialise high‑quality software delivery through an auditable, agent‑human workflow that enables continuous, self‑improving execution across diverse projects—at maximum reliability and minimal risk.**\n\n## 2 · End‑State Vision\n\n| Axis                          | Description                                                                                 |\n| ----------------------------- | ------------------------------------------------------------------------------------------- |\n| **Unified Orchestrator**      | One controller owns coordination; roles are hot‑swappable (human ⇄ agent) without refactor. |\n| **Immutable Auditability**    | Tamper‑proof logs of every state‑transition and decision.                                   |\n| **Continuous Meta‑Learning**  | Meta‑agent detects bottlenecks and policy drift in real time.                               |\n| **Universal Applicability**   | Same pipeline covers ML, infra, analytics, etc.—no bespoke flows.                           |\n| **Transparent Collaboration** | All rationale, context, and hand‑offs observable by any stakeholder.                        |\n\n## 3 · Objectives & Key Results (12‑month)\n\n| Objective                   | Key Results                                                   |\n| --------------------------- | ------------------------------------------------------------- |\n| **O1 · Launch MVP**         | KR1 — autonomous red→green run in *safe\\_inmemory* mode.      |\n| **O2 · Scale Velocity**     | KR2 — median task cycle ≤ 1 day; ≥ 5 tasks/week/dev.          |\n| **O3 · Assure Reliability** | KR3 — 0 regressions post‑commit (tests gate merges).          |\n| **O4 · Expand Autonomy**    | KR4 — ≥ 3 workflow phases fully autonomous, overrides ≤ 10 %. |\n| **O5 · Meta‑optimise**      | KR5 — monthly analytics on bottlenecks & rollback rate.       |\n\n## 4 · Guiding Principles\n\n1. **Explicit Contracts** — single‑responsibility roles with strict I/O.\n2. **Audit by Default** — every action is logged, nothing silent.\n3. **Fail‑Fast Feedback** — surface errors immediately; automate retries where safe.\n4. **No Hidden State** — all state serialised and reconstructable.\n5. **Human‑First Overrides** — allowed, but always logged and reviewed.\n\n## 5 · Glossary\n\n| Term           | Definition                                              |\n| -------------- | ------------------------------------------------------- |\n| **Task**       | Serializable JSON describing work, history, and status. |\n| **Patch**      | Unified diff representing proposed code change.         |\n| **Agent Slot** | Named interface that may be filled by human or agent.   |\n| **MetaAgent**  | Oversight component that analyses workflow telemetry.   |\n\n---\n\n*Change‑log:* 2025‑06‑20 — consolidated vision; removed marketing prose.",
  "docs/DEV_PROCESS.md": "\n# CADENCE DEVELOPMENT PROCESS\n\n*Last‑updated: 2025‑06‑20*\n\n## 1 · Overview\n\nOne canonical document defines *what* must happen and *in what order*. All other docs reference this file to avoid drift.\n\n## 2 · Core Workflow Phases\n\n| Phase        | Role (Class)     | Critical Interfaces                           | Fail Criterion                 |\n| ------------ | ---------------- | --------------------------------------------- | ------------------------------ |\n| **Backlog**  | `BacklogManager` | `list_items`, `add_item`, `archive_completed` | Empty backlog blocks pipeline. |\n| **Generate** | `TaskGenerator`  | `generate_tasks`, `overwrite_tasks`           | Ill‑formed tasks.              |\n| **Execute**  | `TaskExecutor`   | `build_patch`, `refine_patch`                 | Patch invalid or cannot apply. |\n| **Test**     | `ShellRunner`    | `run_pytest`, `git_apply`                     | Test suite fails.              |\n| **Review**   | `TaskReviewer`   | `review_patch`                                | Review rejects diff.           |\n| **Commit**   | `ShellRunner`    | `git_commit`                                  | Commit fails or skipped.       |\n| **Record**   | `TaskRecord`     | `save`, `append_iteration`                    | State not persisted.           |\n| **Meta**     | `MetaAgent`      | `analyse`, `alert`                            | Drift > policy threshold.      |\n\n*Sequence is strict; no phase may be skipped or merged.*\n\n## 3 · Guard Rails\n\n* Tests **and** review must pass before commit.\n* Overrides require explicit rationale and are logged.\n* All artefacts (tasks, diffs, logs) are immutable once archived.\n\n## 4 · Failure Criteria\n\n* Roles perform multiple responsibilities.\n* Orchestration happens outside `DevOrchestrator`.\n* Silent state transitions or missing logs.\n* Context injection exceeds model window constraints (see DEV\\_AGENTS).\n\n## 5 · Reference Architecture Diagram\n\nSee `docs/architecture.mmd` for the system flow.\n\n### Context Selector (planned)\nIf repo snapshot > 50k tokens, ExecutionAgent must call\ncadence.context.select.select_context() with a token budget set in\nDEV_CONFIG.yaml.  The selector walks the module-import graph breadth-first\nuntil the budget is reached.  Doc & code added in commit <SHA>.\n\n---\n\n*Change‑log:* 2025‑06‑20 — merged DEV\\_WORKFLOW & DEV\\_PROCESS; added strict phase table.\n",
  "docs/architecture.mermaid": "\nflowchart TD\nsubgraph Orchestrator\nORCH\\[DevOrchestrator]\nend\n\n```\nsubgraph Roles\n    BACK[BacklogManager]\n    GEN[TaskGenerator]\n    EXEC[TaskExecutor]\n    SHELL[ShellRunner]\n    REV[TaskReviewer]\n    RECORD[TaskRecord]\n    META[MetaAgent]\nend\n\nORCH --> BACK\nORCH --> GEN\nORCH --> EXEC\nORCH --> SHELL\nORCH --> REV\nORCH --> RECORD\nORCH --> META\n\nEXEC --> SHELL\nSHELL --> REV\nREV --> ORCH\n\nSHELL --> RECORD\nREV --> RECORD\nMETA --> ORCH\nMETA --> RECORD\n```\n\n%% End of architecture.mmd\n",
  "docs/DEV_AGENTS.md": "\n# DEV AGENTS — Model Assignment, Profiles & Context Rules  \n\n*Last-updated: 2025-06-20*\n\n## 1 · Why This File Exists  \nThis is the **single source of truth** for how Cadence maps logical roles to concrete LLM\nmodels, context windows, review policy and—new in this revision—`AgentProfile`\nobjects that keep those concerns *out of the Python class hierarchy*.\n\n## 2 · Key Concepts  \n\n| Term            | Description                                                                    |\n| --------------- | ------------------------------------------------------------------------------ |\n| **AgentProfile**| Immutable dataclass declaring model, context limit, review policy, etc.        |\n| **Core Agent**  | Final class that *implements* a capability (Reasoning / Execution / Efficiency)|\n| **Persona**     | Thin wrapper that *delegates* to a Core Agent but presents a different prompt. |\n| **Capability**  | A mix-in or helper that adds specific behaviour (e.g. `CodeContextCapability`).|\n\nSeparation of concerns:  \n\n```\n+------------------+     +--------------+     +----------+\n|  Persona (Sidekick)----> Core Agent ----->  AgentProfile\n+------------------+     +--------------+     +----------+\n                   delegates            references\n```\n\n## 3 · Profiles (Canonical)\n\n| Profile Name | Role Tag          | Model          | Context Limit | Review Path                                   |\n| ------------ | ----------------- | -------------- | ------------- | --------------------------------------------- |\n| `REASONING`  | `plan-review`     | `o3-2025-04-16`| 200 K         | Cannot commit code; must review Execution diff|\n| `EXECUTION`  | `implement`       | `gpt-4.1`      | 1 M           | Needs review by Reasoning or Efficiency       |\n| `EFFICIENCY` | `lint-summarise`  | `o4-mini`      | 200 K         | Reviews Execution unless diff is non-code     |\n\nAll profiles live in `cadence/agents/profile.py`.\n\n## 4 · Core Agents (final)\n\n| Class Name                | Uses Profile | Responsibilities                              |\n| ------------------------- | ------------ | --------------------------------------------- |\n| `ReasoningAgent`          | `REASONING`  | Planning, architecture review, policy checks  |\n| `ExecutionAgent`          | `EXECUTION`  | Code generation / refactor                    |\n| `EfficiencyAgent`         | `EFFICIENCY` | Linting, summarisation, static analysis       |\n\nThese classes are **final**—do not subclass for personas.\n\n## 5 · Personas\n\nA persona combines a *profile* + *prompt* + optional extra helpers by **delegating**\nto one of the Core Agents. Example: `Sidekick` (advisor persona) delegates to\n`ReasoningAgent` but overrides only the system prompt.\n\n## 6 · Context Injection Rules (unchanged)\n\n1. ExecutionAgent may receive full codebase when ≤ 1 M tokens; otherwise chunk.  \n2. Reasoning/Efficiency agents limited to ≤ 200 K tokens per call.  \n3. Module summaries (`# MODULE CONTEXT SUMMARY`) are mandatory for every file.  \n\n## 7 · Governance (unchanged)\n\n* All agent calls log: timestamp, model, prompt token count, hash of output.\n* CI step `lint_docs.py` verifies correct model names and context annotations.\n\n---\n\n*Change-log:*  \n2025-06-20 — Introduced AgentProfile pattern; Core Agents made final; personas use delegation."
}