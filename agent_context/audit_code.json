{
  "src/cadence/audit/llm_call_log.py": "from __future__ import annotations\nimport json, time, os\nfrom pathlib import Path\nfrom threading import RLock\nfrom contextlib import nullcontext\ntry:\n    from filelock import FileLock\nexcept ImportError:\n    FileLock = None  # pragma: no cover\n\nROOT = Path(os.getenv(\"CADENCE_AGENT_LOG_DIR\", \".cadence_logs\"))\nROOT.mkdir(parents=True, exist_ok=True)\n_MAX = 50 * 1024 * 1024                   # 50 MB rotate\n\nclass LLMCallLogger:\n    _inst: \"LLMCallLogger|None\" = None\n    def __new__(cls):\n        if cls._inst is None:\n            cls._inst = super().__new__(cls)\n            cls._inst._init()\n        return cls._inst\n    def _init(self):\n        ts = time.strftime(\"%Y%m%d-%H%M%S\")\n        self._file = ROOT / f\"llm-{ts}.jsonl\"\n        self._lock = RLock()\n        self._flock = FileLock(str(self._file)+\".lock\") if FileLock else None\n    # ------------------------------------------------------------------\n    def log(self, rec: dict):\n        line = json.dumps(rec, ensure_ascii=False) + \"\\n\"\n        ctx = self._flock if self._flock else nullcontext()\n        with ctx, self._lock:\n            with self._file.open(\"a\", encoding=\"utf-8\") as fh:\n                fh.write(line)\n        if self._file.stat().st_size > _MAX:\n            ts = time.strftime(\"%Y%m%d-%H%M%S\")\n            self._file.rename(self._file.with_name(f\"llm-{ts}.jsonl\"))",
  "src/cadence/audit/agent_event_log.py": "from __future__ import annotations\n\nimport json, os, time, uuid\nfrom pathlib import Path\nfrom threading import RLock\nfrom typing import Dict, Any\nfrom contextlib import nullcontext\n\ntry:\n    from filelock import FileLock            # optional, but recommended\nexcept ImportError:                          # pragma: no cover\n    FileLock = None                          # type: ignore\n\n# configurable via env-vars, but sane defaults for CI & dev shells\nLOG_ROOT   = Path(os.getenv(\"CADENCE_AGENT_LOG_DIR\", \".cadence_logs\"))\nMAX_BYTES  = int(os.getenv(\"CADENCE_AGENT_LOG_ROLL_MB\", \"50\")) * 1024 * 1024\nLOG_ROOT.mkdir(parents=True, exist_ok=True)\n\n\nclass AgentEventLogger:\n    \"\"\"\n    Append-only JSON-Lines audit log.\n    Each write = one *event* dict:\n        {ts, event, agent, role?, content?, profile?, context_digest?}\n    \"\"\"\n\n    _instance: \"AgentEventLogger|None\" = None\n\n    # ---------------- singleton boiler-plate -------------------------\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._init()\n        return cls._instance\n\n    def _init(self):\n        ts = time.strftime(\"%Y%m%d-%H%M%S\")\n        self._file = LOG_ROOT / f\"events-{ts}.jsonl\"\n        self._lock = RLock()\n        self._flock = FileLock(str(self._file)+\".lock\") if FileLock else None\n\n    # ---------------- public helpers --------------------------------\n    def register_agent(self, profile: str,\n                       system_prompt: str,\n                       context_digest: str | None = None) -> str:\n        aid = f\"{profile}-{uuid.uuid4().hex[:8]}\"\n        self._write({\n            \"ts\": time.time(),\n            \"event\": \"agent_init\",\n            \"agent\": aid,\n            \"profile\": profile,\n            \"context_digest\": context_digest,\n            \"system_prompt\": system_prompt,\n        })\n        return aid\n\n    def log_message(self, aid: str, role: str, content: str) -> None:\n        self._write({\n            \"ts\": time.time(),\n            \"event\": \"msg\",\n            \"agent\": aid,\n            \"role\": role,\n            \"content\": content,\n        })\n\n    # ---------------- internals -------------------------------------\n    def _write(self, obj: Dict[str, Any]) -> None:\n        line = json.dumps(obj, ensure_ascii=False) + \"\\n\"\n        ctx = self._flock if self._flock else nullcontext()\n        with ctx, self._lock:\n            with self._file.open(\"a\", encoding=\"utf-8\") as fh:\n                fh.write(line)\n\n        # rotate if the file gets too big\n        if self._file.stat().st_size > MAX_BYTES:\n            ts = time.strftime(\"%Y%m%d-%H%M%S\")\n            self._file.rename(self._file.with_name(f\"events-{ts}.jsonl\"))\n            # new empty file will be created automatically on next write"
}